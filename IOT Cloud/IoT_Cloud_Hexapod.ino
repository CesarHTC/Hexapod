/*
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/87725653-15ca-4d7b-a7ca-ffb532ecb76c

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float FSRSensor1_IOT;
  float FSRSensor2_IOT;
  float FSRSensor3_IOT;
  float FSRSensor4_IOT;
  float FSRSensor5_IOT;
  float FSRSensor6_IOT;
  float PATA1Q1_IOT;
  float PATA1Q2_IOT;
  float PATA1Q3_IOT;
  float PATA5Q1_IOT;
  float PATA5Q2_IOT;
  float PATA5Q3_IOT;
  float voltage;
  int bat_percentage;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"
//Battery
int BatteryPin = 0;
int sensorBatteryValue;
float calibration = 0.36;

//Sensors
const int numSensors = 6;
int fsrPins[numSensors] = {0, 1, 2, 3, 4, 5}; //Pines analogicos

//Servo
const int numServos = 6;
float servoReadings[numServos];

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(115200);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);
  /*
    //Inicializacion de los sensores FSR
    fsrPins[0] = analogInputToDigitalPin(A0);
    fsrPins[1] = analogInputToDigitalPin(A1);
    fsrPins[2] = analogInputToDigitalPin(A2);
    fsrPins[3] = analogInputToDigitalPin(A3);
    fsrPins[4] = analogInputToDigitalPin(A4);
    fsrPins[5] = analogInputToDigitalPin(A5);
    //----------------------------------------------------
    IOT Cloud no permite el uso de pines como A1,A0 etc....*/

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information you’ll get.
     The default is 0 (only errors).
     Maximum is 4
  */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}

void loop() {
  ArduinoCloud.update();
  // Your code here
  FSRSensor_Read();
  BatteryInfo();
  readServoPositions(servoReadings, numServos);


}



/*
  Since Led is READ_WRITE variable, onLedChange() is
  executed every time a new value is received from IoT Cloud.

  void onLedChange()  {

  // Add your code here to act upon Led change
  if(led == 1)
  {
    digitalWrite(2,HIGH);
  }
  else
  {
    digitalWrite(1,LOW);
  }

  }
*/
//////////////////////////////////   FSR Sensors  //////////////////////////////
void FSRSensor_Read() {
  //Lectura de los datos de los sensores de fsr
  for (int i = 0; i < numSensors; ++i) {
    fsrPins[i] = analogRead(fsrPins[i]);
    delay(10);//Reducir el ruido de la señal de los sensores fsr

  }

  //Impresion de los valores en el monitor y aplicacion de thresholds dependiendo de la fuerza aplicada al sensor
  for (int i = 0; i < numSensors; i++) {
    Serial.print("FSR ");
    Serial.print(i);
    Serial.print(":");
    Serial.print(fsrPins[i]);

    //Arreglo de los valores para actualizarlos de manera mas eficiente
    float *iotVariables[] = {
      & FSRSensor1_IOT,
      & FSRSensor2_IOT,
      & FSRSensor3_IOT,
      & FSRSensor4_IOT,
      & FSRSensor5_IOT,
      & FSRSensor6_IOT
    };

    //Update IoT
    if (i < sizeof(iotVariables) / sizeof(iotVariables[0])) {
      *iotVariables[i] = fsrPins[i];
    }

    /*//Update IOT Cloud values
      if(i == 0){
      fSRsensor_1 = fsrPins[i];
      }
      else if(i == 1)
      {
       fSRsensor_2 = fsrPins[i];
      }
      else if (i == 2)
      {
      fSRsensor_3 = fsrPins[i];
      }
      else if(i == 3)
      {
       fSRsensor_4 = fsrPins[i];
      }
      else if (i == 4)
      {
       fSRsensor_5 = fsrPins[i];
      }
      else if (i == 5)
      {
       fSRsensor_6 = fsrPins[i];
      }


      Serial.println();
      if else no es muy eficiente mejor utilizar punteros y arreglos para las variables*/
    //Thresholds
    if (fsrPins[i] < 10)
    {
      Serial.println("-No pressure");
    }
    else if (fsrPins[i] < 200)
    {
      Serial.println("-Light touch");
    }
    else if (fsrPins[i] < 500)
    {
      Serial.println("-Light squeeze");
    }
    else if (fsrPins[i] < 800)
    {
      Serial.println("-Medium squeeze");
    }
    else
    {
      Serial.println("-Big squeeze");
    }
    delay(1000);
  }
}

//////////////////////////////////    Battery     //////////////////////////////
void BatteryInfo() {
  sensorBatteryValue = analogRead(BatteryPin);
  voltage = mapfloat(sensorBatteryValue, 0, 1023, 0, 3.3);
  voltage += calibration;//añadir la calibracion despues del mapeo importante la calibracion depende del valor del voltaje dado con el circuito en funcionamiento


  bat_percentage = mapfloat(voltage, 6.6, 8.4, 0, 100); //Cambiar los valores de voltaje dependiendo de la bateria voltaje de corte 2.8 y 4.2V como maximo voltaje verificar en la datasheet de la bateria

  if (bat_percentage >= 100)
  {
    bat_percentage = 100;
  }
  if (bat_percentage <= 0)
  {
    bat_percentage = 1;
  }

  Serial.print("Analog Value= ");
  Serial.print(sensorBatteryValue);
  Serial.print("\t Output Voltage");
  Serial.print(voltage);
  Serial.print("\t Battery Percentage= ");
  Serial.println(bat_percentage);
  delay(1000);
}
//Explicacion del calculo del voltaje de la bateria
/*
  in_min y in_max:maximos y minimos de los valores del rango de entrada en este caso nuestro nivel de voltaje
  out_min y out_min:maximos y minimos de los valores del rango de salida
  la linea(x- in_min):calcula la distancia de x tomando de base el valor minimo del rango de entrada
  la linea(out_max - out_min)/ (in_max - in_min): calcula el valor del factor de escala que existe entre el rango de entrada y el rango de salida
  la linea(+ out_min):cambia el valor escalado para comenzar desde el limite inferior de la salida
  x es el valor mapeado desde el limite inferior del rango de entrada y el limite superior del rango de entrada
*/
float mapfloat(float x, float in_min, float in_max, float out_min, float out_max)
{
  return (x  - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}
//////////////////////////////////    Servomotors IOT Cloud Readings     //////////////////////////////
void readServoPositions(float readings[], int numServos) {
  for (int i = 0; i < numServos; i++) {
    //implementar el codigo de lectura del codigo de lizarraga o hacer referencias los codigos del ide arduino
    readings[i] = readServo(i);
  }
}
float readServo(int servoIndex) {
  return 0.0; // Replace with the actual value
}
